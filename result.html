<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>K·∫æT QU·∫¢ PH√ÇN PH·ªêI</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="./asset/css/result.css">
</head>
<body>

<h1>K·∫æT QU·∫¢ PH√ÇN PH·ªêI THEO KHU V·ª∞C</h1>
<div class="layout">
  <div class="left-panel">
    <div class="info-block"><label>Kho h√†ng:</label><span id="addressC"></span></div>
    <div class="info-block"><label>Danh m·ª•c h√†ng h√≥a:</label><span id="dishName"></span></div>
    <div class="info-block"><label>H·∫°n s·ª≠ d·ª•ng:</label><span id="expiryDate"></span></div>
    <div class="info-block"><label>Khu v·ª±c ∆∞u ti√™n:</label><span id="regionName"></span></div>
    <div class="info-block"><label>Chi ph√≠ ∆∞·ªõc t√≠nh (km):</label><span id="totalCost"></span></div>

    <h3>Th√¥ng tin nh√† cung c·∫•p</h3>
    <table>
      <thead>
        <tr>
          <th>T√™n nh√† cung c·∫•p</th>
          <th>ƒê·ªãa ch·ªâ</th>
          <th>M·∫∑t h√†ng</th>
          <th>S·ªë l∆∞·ª£ng</th>
          <th>ƒê∆°n v·ªã</th>
        </tr>
      </thead>
      <tbody id="supplierTable"></tbody>
    </table>

    <h3>Ph√¢n b·ªï chi ti·∫øt</h3>
    <table>
      <thead>
        <tr>
          <th>ƒê·ªãa ƒëi·ªÉm</th>
          <th>S·ªë ng∆∞·ªùi c·∫ßn</th>
          <th>S·ªë su·∫•t ph√¢n ph·ªëi</th>
        </tr>
      </thead>
      <tbody id="allocationsTable"></tbody>
    </table>
  </div>

  <div class="right-map">
    <div id="map" style="height: 600px;"></div>
  </div>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  const result = JSON.parse(localStorage.getItem("resultData"));
  if (!result) {
    alert("Kh√¥ng c√≥ d·ªØ li·ªáu k·∫øt qu·∫£!");
    throw new Error("Kh√¥ng t√¨m th·∫•y resultData trong localStorage.");
  }

  document.getElementById("addressC").textContent = result.addressC;
  document.getElementById("dishName").textContent = result.dishName;
  document.getElementById("expiryDate").textContent = new Date(result.expiry).toLocaleString("vi-VN");
  document.getElementById("regionName").textContent = result.regionName;
  document.getElementById("totalCost").textContent = result.totalCost + " km";

  const supplierTable = document.getElementById("supplierTable");
  (result.suppliers || []).forEach(s => {
    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${s.name}</td>
      <td>${s.address}</td>
      <td>${s.item || ''}</td>
      <td>${s.supply || ''}</td>
      <td>${s.unit || ''}</td>
    `;
    supplierTable.appendChild(row);
  });

  const table = document.getElementById("allocationsTable");
  result.allocations.forEach(item => {
    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${item.address}</td>
      <td>${item.demand}</td>
      <td><strong>${item.allocated}</strong></td>
    `;
    table.appendChild(row);
  });

  const map = L.map('map').setView([10.762622, 106.660172], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  async function getRouteGeometry(from, to) {
    const url = `https://router.project-osrm.org/route/v1/driving/${from[1]},${from[0]};${to[1]},${to[0]}?overview=full&geometries=geojson`;
    const res = await fetch(url);
    const data = await res.json();
    if (!data.routes?.length) return null;
    return data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
  }

  (async () => {
    const boundsCoords = [];
    if (result.warehouseCoord) {
      L.marker(result.warehouseCoord).addTo(map).bindPopup("üè¨ Kho h√†ng").openPopup();
      boundsCoords.push(result.warehouseCoord);
    }

    for (const s of result.suppliers || []) {
      if (s.coords && result.warehouseCoord) {
        L.marker(s.coords).addTo(map).bindPopup(`üè≠ ${s.name}`);
        boundsCoords.push(s.coords);
        const geometry = await getRouteGeometry(s.coords, result.warehouseCoord);
        if (geometry) {
          L.polyline(geometry, { color: 'red', weight: 4 }).addTo(map);
          geometry.forEach(p => boundsCoords.push(p));
        }
      }
    }

    for (const loc of result.allocations || []) {
      L.marker(loc.coords).addTo(map).bindPopup(`üìç ${loc.address}<br>Ph√¢n ph·ªëi: ${loc.allocated} su·∫•t`);
      boundsCoords.push(loc.coords);
      if (result.warehouseCoord && loc.coords) {
        const geometry = await getRouteGeometry(result.warehouseCoord, loc.coords);
        if (geometry) {
          L.polyline(geometry, { color: 'green', weight: 3 }).addTo(map);
          geometry.forEach(p => boundsCoords.push(p));
        }
      }
    }

    map.fitBounds(L.latLngBounds(boundsCoords));
  })();
</script>

</body>
</html>
